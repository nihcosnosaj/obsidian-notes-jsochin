## Compiling Source Code
- The C++ compiler sequentially goes through each source code (.cpp) file and does two important tasks:
	- checks your C++ code to make sure it follows rules of language
	- translates your C++ code into machine language instructions
		- Stored in an intermediate Object file (name.o or name.obj)

## Linking object files
- After the compiler has finished, a program called the *linker* kicks in. 
- Combines all of the object files and produce the desired output file (such as an exectuable file you can run). this is called Linking.
	- First, the linker reads in each of the object files generated by the compiler and makes sure they are valid.
	- Second, the linker ensures all cross-file dependencies are resolved properly. 
		- If you define something in one .cpp file and use it in another .cpp file, the linker connects the two together. 
	- Third, the linker typically links in one or more library files, which are collections of precompiled code that have been "packaged up" for reuse in other programs.
	- Finally, the linker outputs the desired output file. Typically an executable but it could be a library file. 


## The Standard Library
- C++ comes with an extensive library called the C++ Standard Library.


## Building
- Because of the multiple steps involved, the term *building* is often used to refer to the full process of converting source code files into an executable that can be run. 
- A specific executable produced as a result of building is sometimes called a *build* 
- There are build automation tools (make and build2) that help automate the build process and running automated tests. 


### Lanugage Standard
- C++ 20


## Statements and the structure of a program
- A computer program is a sequence of instructions that tell the computer what to do.
- A **statement** is a type of instruction that causes the program to perform some action.
	- The smallest independent unit of computation in C++. 
	- Most statements in C++ end in a semi-colon (;)
- In a high-level language like C++, a single statement may compile into many machine language instructions.
- Types of Statements:
	- Declaration Statements
	- Jump statements
	- Expression statements
	- Compound statements
	- Selection statements (conditionals)
	- Iteration statements (loops)
	- Try blocks

### Functions and the `main` function
- Statements are grouped into units called *functions* 
- A *function* is a collection of statements that get executed sequentially. 
- Every C++ program must have a special function named *main* 
- When the program is run, statements inside of `main` are executed in sequential order.
- Program's typ


```C++
// A preprocessor directive; indicates we want to use the contents // of the iostream library.
#include <iostream>

// We are defining a function main() that produces a value of type // int (integer)
int main()
{
	// cout --> character output
	std::cout << "Hello world!";
	return 0;
}
```

`#include` is something called a *preprocessor directive* that says we would like to use the contents of `iostream` library

```C++
// Example function definition
int add(int a, int b) {
	return a + b;
}
```

We just need to specify the return type, function name (identifier) and parameters.

You can then call `add(2, 3)` to get `5` .


## Syntax and Syntax Errors
- C++ has a very strictly defined syntax rulebook.
- The compiler will generally point you directly to the syntax error.

## Comments
- C++ has two different comment styles.
- *Single Line Comments* 
	- `//` begins a C++ single line comment, which tells the compiler to ignore everything from `//` to the end of the line.
	- The `//` comes AFTER the semicolon line ender.
- *Multi Line Comments*
	- `/* */` pair of symbols denotes a C-style multi-line comment. Everything in between the symbols is ignored by the compiler. 


## Objects and Variables
- *Objects* in C++ represent a region of storage that can hold a value.
- An Object with a name is called a *Variable*.
- To define a variable:
	- `int x; // define a variable named x (of type int)`

Compile-time vs Run-time

### Random Access Memory
- RAM
- The main memory in a computer.
- When we run a program, the OS loads the program into RAM. 
- The OS also reserves some RAM for the program to use while it is running. 



In C++, you have to manage memory yourself, using concepts like pointers (new, delete) and more modern smart pointers (unique_ptr, shared_ptr). Manual allocation and deallocation is a new challenge

Learn about RAII (resource acquisition is initialization)

In C++, you need to understand the seperate stages of compliation: preprocessing, compilation, and linking. You'll use compilers like `g++` or `clang++` and a build system like `CMake` to manage projects with multiple files. 

C++20
- Use the STL (standard template library) - provides containers like std::vector or std::map, algorithms and iterators that are similar in purpose to Python's built-in data sturctures. Use these instead of raw arrays.

- Use `std::unique:ptr` and `std::shared_ptr` to handle memory automatically, reducing the risk of memory leaks.



### Naming
- User-defined class names and function names use pascal case (LinkedList())
- Variables names are all lowercase, with underscores between words (student_id)

### Indentation
- All indentations should be two spaces (no tabs or four spaces)

### Line length
- at most 80 characters long
- 

### CLI compiling
- `g++ MyProgram.cpp -o MyProgram`
- `./MyProgram` to run the executable


### Program structure
- Preprocessor directives --> a special type of statment with the `#` symbol that are examined before actual compilation.
	- `#include` to import libraries. 
		- Standard library names must be enclosed in `<>` 
		- User-defined library names must be enclosed in `" "` 
- `using namespace std;`
	- introduces the namespace `std` to the current program. This allows usage of the standard library objects without prepending the `std::` identifier. 
	- If this isn't there, any time you use `cout` it must be prepended with `std::cout` 
- The `main()` function
	- Every C++ program must have one to run.
	- Format goes: `returntype main() {logic}`


### Input/Output Library
- `iostream` -- deals with basic input and output
- Insertion operator --> `<<` 
- To end a line, either `\n` in the string or `<< std::endl` -- usage is interchangeable


## Variables
- A *Variable* is a name that represents a particular peice of the computer's memory that has been set aside for storing, retrieving, and using data.
- To create a variable, you need:
	- data type
	- name
	- value (must match type)
- To declare a variable:
	- `type name = value;`
	- Remember, variable names are all lowercase and underscores
- To define a variable (no value assigned, just named):
	- `type name;`
- Assigning a variable:
	- `name = new_value` 

```C++

// Define a variable called letter
char letter;

// Declare a variable called number and initialize it to 21
int number = 21;

// Assign 18 to number
number = 18; // number is now 18
```

- Multiple variables of the same type can be declared in a single statment using a comma-seperated list: `int a = 1, b = 2, c = 3;`
- Constant variables
	- variables that cannot be changed after initialization; meant to protect the value from being changed accidentally elsewhere
	- `const double pi = 3.14` 
	- Cannot declare a constant wihtout a value (can't just define it)

## Data types
![[Pasted image 20250731143719.png]]

- A variable in C++ must be assigned a specific type. 
- Type conversion?
	- it is possible to convert from int into double and vice versa.
	- the notation `(type) value` means convert `value` into `type` 
	- Note, going from double to int simple removes the decimal, it doesn't round up. 
- `std:;string` stores a sequence of `char` surrounded by double quotes.
	- not a buiilt-in type, must be included `#include <string>` 
	- comes with plenty of useful methods 
		- `+` to concatenate
		- `[]` for index access at specific index in string (C++ is also zero indexed)
		- `length()` can get the length of a string.
```C++
#include <iostream>
#include <string>	// for std::string

int main() {
  // int
  int length = 5;
  std::cout << length << std::endl;

  // double
  double pizza_price = 12.99;
  std::cout << pizza_price << std::endl;

  // Type conversion from double to int
  double x = 6.7;
  int y = (int) x;		// y is now 6
  std::cout << "After conversion, " << x << " becomes " << y << std::endl;

  // char
  char first_letter = 'a';
  std::cout << first_letter << std::endl;

  // string
  std::string word = "Code";
  std::cout << word << std::endl;
  
  // concatenation
  std::string name = word + "cademy";
  std::cout << name << std::endl;

	// char access
  std::cout << "The third letter of " << name << " is " << name[2] << std::endl;

	// string length
  std::cout << "There are " << name.length() << " letters in " << name << std::endl;

  // boolean
  bool a = true;
  a = false;
  std::cout << a;

  return 0;
}

```


### Operators

- In an operation, symbols are either an operand or an operator
- `int n = 3 + 4;`
- ![[Pasted image 20250801074037.png]]

- Pre vs Post Increment
	- increment and decrement operators both have a pre and post operation. 
		- Pre:
			- the value stored in the operand is incremented/decremented first, and then that operand is returned.
		- Post:
			- a copy of the operand is made, then that operand (not the copy) is incremented/decremented, and then the copy is evaulated.
```C++
int x = 10;

int y = x--;

std::cout << x << ' ' << y;
```


- Assignment Operators

![[Pasted image 20250801075739.png]]

- Relational Operators

![[Pasted image 20250801075811.png]]

- Logical Operators

![[Pasted image 20250801075835.png]]

![[Pasted image 20250801075856.png]]


- Operator Precedence:
	- ![[Pasted image 20250801080109.png]]


## References and Pointers

Learn how to manipulate memory in C++

When a variable is declared (`int x = 10;`) - a free memory address is set aside for the purpose of storing the value inside that variable. C++ provides two powerful features that allow programmers to directly manipulate memory:
- References
- Pointers

#### Reference
- A *reference* variable is an alias to an existing variable. 
- Declared by using an ampersand `&` between the reference type and the variable name
- `int exam_grade = 85;`
- `int& score = exam_grade;`
- The `score` variable is an alias/reference to the `exam_grade` variable. When the value of `score` is changed, the value of `exam_grade` will also change in the same way. 
- To note on references:
	- References must be initialized! (no such thing as en empty reference)
	- References cannot be reassigned! 
- Primary application:
	- the primary application for references in C++ is in function parameters.
		- because the reference parameter acts as an alias for the argument, a function that uses a reference parameter is able to modify the argument passed in.

### Memory Address
- When not use in declaration, the ampersand symbol `&` is called the *address of* operator and is used to access the memory address of a variable. 
- This is done by preceding the name of the varaible with `&`
	- `std::cout << &message << std::endl; // prints memory address of message`
	- Will output the memory address in hexadecimal

### Pointers
- A *pointer* in C++ is a variable that stores a memory address as its value.
- Declared with an asterisk `*` between the data type and the variable name. 
- A pointer variable must point to a data type of the same type. 
	- `int*` means pointer to an int variable
	- `int* age;` 
	- `char* initial;`
- Just like normal variables, pointers are empty when they are declared and need to be initialized. 
- Pointer variables are usually assigned with a memory address obtained by the *address of* operator `&`:
	- Suppose we have a variable called `day`: `std::string day = "Monday";`
	- We can create a pointer variable called `ptr` and point to it by: `std::string* ptr = &day`
- Pointers are simliar to referneces in the way that when the pointer's value changes, the value of the original variable also changes in the same way:
```C++
*ptr = "Friday";

// Print: Friday
std::cout << *ptr << std::endl;

// Print: Friday
std::cout << day << std::endl;
```

### Dereference
- When NOT used in a declaration, the asterisk symbol `*` is called the *dereference* operator.
- Used to obtain the value pointed to by a pointer variable.

### Null Pointer
- It's dangerous to leave a pointer uninitialized.
- If unsure where to point, assign the variable to `nullptr` which is a keyword that provides a typesafe pointer value representing an empty pointer. 

```C++
#include <iostream>

#include <string>

  

int main() {

std::string name = "John";

std::string* ptr = nullptr;

ptr = &name;

std::cout << ptr << '\n';

std::cout << *ptr << '\n';

*ptr = "Robin";

std::cout << *ptr << '\n';

std::cout << name << '\n';

return 0;

}
```


## Conditional Statements

#### `if` statements
- Used to test an expression for truth.
- If the condition evaluates to true, the code within gets executed.
- `if (condition) { code here gets ran }`

#### `else` statements
- Can be added after an `if` statement. Opposite to `if`, the code within the else block will only be executed if the condition is false.
- `if (condition) {} else {code if condition is false}`

You can also rope these together:
```C++
if (condition1) {
	// code to run if condition1 is true
}
else if (condition2) {
	// code to run if condition1 is false and condition2 is true
}
else {
	// code to run if both condition1 and condition2 are false
}
```

#### Shorthand if-else
- Its possible to condense an if-else statement into a single statement using the following syntax:
	- `variable = (condition) ? condition_is_true : condition_is_false;`

	For example, intstead of writing:
```C++
int time = 10;
std::string greeting;
if (time < 12) {
	greeting = "Good Morning!";
}
else {
	greeting = "Good afternoon!";
}
```
You can use the shorthand:
```C++
int time = 10;
std::string greeting = (time < 12) ? "Good morning!" : "Good afternoon!";
```


#### Omiitting brackets
- Curly brackets {} may be OMITTED if there is only a single statement inside an `if`, `else if` or `else` block:
```C++
if (number == 7)
	std::cout << "Lucky!\n";

if (number == 7) {
	std::cout << "Lucky!\n";
}
```
- While it does save space and improve readability, it is generally considered bad because it easily introduces bugs into the program.


## `switch` statements
- A type of conditional statement in C++ that provides a means of checking an expression against various cases. If there is a match, the code within the block starts to execute.

```C++
switch (grade) {
	case 9:
		std::cout << "Freshman\n";
		break;
	case 10:
		std::cout << "Sophomore\n";
		break;
	case 11:
		std::cout << "Junior\n";
		break;
	case 12:
		std::cout << "Senior\n";
		break;
	default:
		std::cout << "Invalid\n";
		break;
}

```

### `switch` vs `if-else` 
- For conditional statements with multiple outcomes, `if-else` chains are tedious to write.
- Aside from making the code more readable, `switch` statements are also optimized because the expression is only evaluated once. 

#### `break`
- the `break` keyword signals the compiler to jump out of a case. 

### `default`
- The `default` keyword is used to specify a code block to be run if none of the cases are true. Similar to an else statment. 



## Loops

### `while` loops
- The `while` loop repeats a block of code as long as the given boolean condition is `true`.
```C++
int count = 1;
while (count <= 5) {
	std::cout << count;
	count++;
}
```

- The code within the above while loop will execute as long as count is less than or equal to 5.

#### `counter ` variable
- a counter or iterator is a variable that is responsible for iterating (repeating) a loop and causing it to stop.

### `do-while` loops
- very similar to a while loop, but will always execute AT LEAST ONCE, even if the condition is initially false!
```C++
int price = 300;
do {
	std::cout << "Too expensive!";
} while (price > 500);
```

### `for` loops
- The `for` loop should be used WHEN the programmer knows exactly how many times a block of code needs to be repeated!

```C++
for (int i = 1; i <=5; i++) {
	std::cout << i;
}
```

- Made up of three parts:
	- initialization of a counter variable (`int i = 1`)
	- the condition for executing the code block as long as its true: `i <= 5`
	- the increment/decrement of the counter variable (`i++`). Executed after every iteration of the loop.

### `for-each` loops
- The `for-each` loops is especially useful for iterating through list-like structures such as arrays or `std::vector` 
```C++
int fibonacci[5] = {0, 1, 1, 2, 3};
for (int number : fibonacci) {
	std::cout << number;
}
```

- This for-each lop iterates through an array called `fibonacci` using the counter variable number.

#### `auto` keyword
- When iterating through an array using `for-each`, the counter variable may be declared using the auto keyword
- `auto` lets C++ deduce the type of the variable based on the type of the list it belongs to.
```C++
int fibonacci[5] = {0, 1, 1, 2, 3}
for (auto number : fibonacci) {
	std::cout << number;
}
```


### `break` and `continue`
- The `break` keyword can be used to jump out of a loop.
- When its executed, any code below it is not ran

- `break` or `return`?
	- a `break` statement is used to terminate a switch or loop, and code execution will continue to the line after the switch or loop.
	- `return` terminates the entire function and resumes code execution at the point where the function was called. it also returns something back to the caller, unlike break.

- `continue` 
	- The `continue` keyword can be placed inside a loop to skip over one iteration of the loop. If `continue` is executed, the current loop iteration will end, and the next iteration will begin.
```C++
for (int i = 0; i < 10; i++){
	if (i == 4) {
		continue;
	}
	std::cout << i;
}
```



## Functions
- A *function* in C++ contains a set of instructions that are executed when it is called. Functions make code flexible and reusable.

#### Creating a function
- A function is made up of two components:
	- *Declaration*: the functions name, return type, and paramenters.
	- *Definition*: the body of the function containing the code to be executed.
```C++
void doSomething() { // Declaration
	std::cout << "Functions are great!\n"; // Definition
}
```

- void means the funciont doesnt have any return value
- () is the parameter list.


#### Calling a function
```C++
// Create a function
void doSomething() {
	std::cout << "Functions are great!\n";
}

int main() {
	// Call the function
	doSomething();
	doSomething();
}
```

#### Return type and value
- The programmer can choose whether a function returns something back to the caller. 
- If a function doesn't return a value, it should be delcared as a `void` function
- A function that returns a vlue needs two things:
	- `Return type` : the type defined before the functions name. (int, double, bool)
	- `Return value` : the specific value returned from the function using the return keyword.

#### Function Scope
- Scope defines the region of code that can access or view a given variable.
- No different from other type of scopes; variables declared inside a function are only accessible inside that function.

### Function Parameters
- In C++, function parameters are variables that act as placeholders for input values passed to a function. They act as variables inside a function. 
#### Parameters
- Function parameters are defined inside the function declaration and placed inside the parentheses () after the function name. 
- Each parameter must be defined with a name and data type.
- `int feetToInches(int ft) {}`
- Functions can have multiple parameters: `double totalPrice (int items, double price, bool discount) {}`

##### Default Parameters
- default parameters make it possible to call a function without including all the arguments. ANy argument abset from the function call is replaced with the default value associated with that parameter
```C++
void message(std::string language = "C++") {
	std::cout << "I like to code with " << language << "\n";
}

int main() {
	// Function call without an argument
	message();

	// Function call with an argument
	message("Java");
}
```


#### Arguments
- a function argument is a vlue that is passed to the function when performing a function call. Arguments must be the same data type as the parameters.

#### Pass by Reference
- *Pass by reference* allows a function to modify the values of its argument variables.
- Use the reference operator (`&`) to indicate that a parameter is passed by reference.

```C++
void swap(int &i, int &j) {
	int temp = i;
	i = j;
	j = temp;
}

int main() {
	int first = 10;
	int second = 20;

	std::cout << "Before swap: " << first << " " << second << "\n";

	swap(first, second)

	std::cout << "After swap: " << first << " " << second << "\n";
}
```



## Function Overloading
- *function overloading* allows multiple functions to have the same name as long as they differ in their parameters. 
- Enables functions to handle different types/numbers of inputs.

```C++
// Adds two int values
int add(int a, int b) {
	return a + b;
}

double add(double a, double b) {
	return a + b;
}
```


- In order to differentiate overloaded functions, at least one of the following must be true:
	- Each function has different type of parameters
	- Each function has a different number of parameters.
- The function return type is NOT used to differentiate overloaded functions.

## Command Line Arguments
- To access command line arguments, `main()` must take two arguments: `int main(int argc, char **argv)`
	- `argc` --> argument count; an int parameter containing the number of command line arguments passed to the program. Value is always at least one because the name of the exectuable is treated as an argument.
	- `argv` --> argument vector; an array parameter containing the values of command line arguments. The range of argv spans from 0 to argc - 1. 

```C++
#include <iostream>

int main(int argc, char* argv[]) {
	for(int i = 0; i < argc; i++) {
		std::cout << "arg " << i << ": " << argv[i] << "\n";
	}
	return 0;
}
```

When the above program is compiled and executed with: `./greeting Code cademy` , the output will be:
```
arg 0: ./greeting
arg 1: Code
arg 2: cademy
```

NOTE: `argv[0]` is always the name of the exectuable.

### Special Characters
- Command line arguments are usually seperated by spaces. If an argument itself contains spaces, it needs to be enclosed in double-quotes " " to be considered a single string.
- Any other special characters need to be escaped!



## Classes and Objects
Object-Oriented Programming

*Class*
- a user-defined data type that encapsulates information and serves as a blueprint for *objects* (instances of classes)
- To create:
	- use the `class` keyword:
	- `class School {};`
- Components of a class are called *class members*:
	- *Attributes* --> also known as member variables, contain info about an object of the class.
	- *Methods* --> aka member functions, are functions that belong to the class.

```C++
class School {
public:
	std::string name;
	int age;

	void banner() {
		std::cout << name << " is " << age << " years ld.\n";
	}
};
```

- In the above code, three class members have been added to `School` -->
	- `name` is an attribute of type `std::string`
	- `age` is an attribute of type `int`
	- `banner()` is a method that has a return type of `void`
- The `public` keyword is an access specifier that allows members of `School` to be directly accessed outside the class. 

For larger projects, it's recommended to split up the class definition in a header and a `.cpp` file. Doing so requires class methods to be defined outside of the class definition. In this scenario, the `ClassName::` namespace to indicate that the function belongs to that class.

#### Defining Methods Outside of a Class
- For larger projects, its recommended to split up the class definition in a header and a .cpp file. Doing so requires class methods to be defined outside of the class defintion. 
```C++
void School::banner() {
	std::cout << name << " is " << age << " years old.\n";
}
```

## Objects
- Creating an object is very similar to creating a variable; simply specify the class name followed by the object name. For example, to create an object of `School`:
- `School codecademy;`
- Once an object is created, we can access and modify the class attributes using the dot operator `.` :
	- `codecademy.name = "Codecademy";`
	- `codecademy.age = 10;`
- Note: these attributes are only accessible because they were declared under hte public section of `School`
- We can use the dot operator to call methods too! --> `codecademy.banner();`

### Access Specifiers
Control access of class members

*Access specifiers* are C++ keywords that determine the scope of class components. 

#### The `private` keyword
- By default, all class members are declared `private` - they cannot be accessed outside of the class.
- When you use other types of access specifiers, `private` may need to be stated explicitly. Everything declared below `private:` is private to the class.
#### The `public` keyword
- The `public` access specifier has the opposite effect of `private`; `public` class members are accessible from anywhere in the program. 
- The `public` access specifier is best reserved for methods, not for attributes.
- Public methods provide a means for the program to interact with an instance of the class.
- C++ provides a third access specifier: `protected` -- works like `private`, but allows inherited classes to access those class members. 

### Encapsulation
- *Encapsulation* is very important in OOP. 
- It means to hide sensitive details about an object's implementation away from the user. 
- In C++, encapsulation is achieved by declaring class members/attributes as `private` so they cannot be accessed from outside the class.
- However, other parts of the program might need to read of modify the values of private class members -- this is where `accessor functions` and `mutator functions` come in.

#### Accessor Functions
- also known as a `getter` function, is a `public` function that returns the value of a private member variable. 
```C++
class Clock {
private:
	int time = 1200;

public:
	// Accessor function for time.
	int getTime() {
		return time;
	}

	// Mutator function for time
	void setTime(int new_time) {
		time = new_time;
	}
};

int main() {
	Clock alarm;
	alarm.setTime(930);
	std::cout << alarm.getTime(); // Output: 930
}
```


#### Mutator Functions
- also known as a `setter` function, is a `public` function that sets the value of a `private` member variable. 
- Usually have a return type of `void` 

## Constructors
Initialize objects with constructors.

- A *constructor* in C++ is a special kind of method that is automatically called when an object of the class is created. A constructor has the same name as the class and has no return type (not even void).
- Usually used to initialize class attributes and do any necessary setup work!

#### Default Constructors
- A *default* constructor is a constructor that takes NO parameters. 
- If the object is created without specifying the initialization values, the default constructor will be called.

```C++
class House {
private:
	std::string location;
	int rooms;

public:
	// Default constructor
	House() {
		location = "New York";
		rooms = 5;
	}

	void summary() {
		std::cout << location << " house with " << rooms << " rooms.\n";
	}
};
```


Just like methods, constructors can be defined outside of their class definitions. Use the ClassName:: namespace to indicate that the constructor belongs to that class. 

```C++

House::House() {
	location = "New York";
	rooms = 5;
}
```

Similar to functions, constructors can be declared with parameters. Constructors with parameters allow objects to be instantiated with specific values. 

Let's add a constructor to the House class that takes two parameters:
```C++
class House {
private:
	std::string location;
	int rooms;

public:
	// default constructor
	House(std::string loc, int num) {
		location = loc;
		rooms = num;
	}

	void summary() {
		std::cout << location << " house with " << rooms << " rooms.\n"
	}

}
```

```C++
int main() {
	House green_house("Boston", 3); // Calls House(std::string, int) constructor

	green_house.summary();

	return 0;
}
```

```C++

```